
import { Canvas, Meta, Story, ArgsTable, Source } from '@storybook/addon-docs';
import SortableTable from '@shell/components/SortableTable';

<Meta 
  title="Components/Table"
  component={SortableTable}
/>

export const Template = (args, { argTypes, events }) => ({
  components: { SortableTable },
  props:      Object.keys(argTypes),
  template:   `<SortableTable v-bind="$props"/>`
});

export const rows = [
  {
    name: 'First row',
    description: 'This is the first row',
    type: 'first type',
  },
  {
    name: 'Second row',
    description: 'This is another row',
    type: 'first type',
  },
  {
    name: 'No description',
    description: '',
    type: 'second type',
  },
];

export const headers = [
  {
    name: 'name',
    label: 'Name',
  },
  {
    name: 'description',
    label: 'Description',
  },
  {
    name: 'type',
    label: 'Type',
  },
];

# Table

Table with multiple functionalities. 

Note: Within our project 2 tables exists for this purpose: `SortableTable` and `ResourceTable`. 
The first one is an abstracted version, while the `ResourceTable` is a wrapper bound to the state.

## Description

This is just a visual rapresentation of the Rancher tables.
As the component ties in to product config, models, stores, etc, consider some existing docs as well during the development

- https://rancher.github.io/dashboard/code-base-works/sortable-table
- https://rancher.github.io/dashboard/code-base-works/kubernetes-resources-data-load
- https://rancher.github.io/dashboard/code-base-works/customising-how-k8s-resources-are-presented#list

<br/>

### Styles and sections

#### Default view

Default view case without change any prop and just providing required data.

<Canvas>
  <Story
    name="Default view"
    args={{
      headers,
      rows,
    }}>
    {Template.bind({})}
  </Story>
</Canvas>

#### Grouped

Rows can be grouped by matching types.

<Canvas>
  <Story
    name="Grouped view"
    args={{
      headers,
      rows,
      groupBy: 'type',
    }}>
    {Template.bind({})}
  </Story>
</Canvas>

#### Simplified

The default table can also be stripped out of each interactive functionality by props.

<Canvas>
  <Story
    name="Simplified view"
    args={{
      headers,
      rows,
      search: false,
      rowActions: false,
      tableActions: false,
    }}>
    {Template.bind({})}
  </Story>
</Canvas>


#### Loading

Loading status for the table.

<Canvas>
  <Story
    name="Loading"
    args={{
      headers,
      rows: [],
      loading: true
    }}>
    {Template.bind({})}
  </Story>
</Canvas>

#### Slots

### Functionalities

#### Advanced Filtering

Entries can be optionally filtered by key and term or optionally hide them.

<Canvas>
  <Story
    name="Advanced Filtering"
    args={{
      headers,
      rows,
      hasAdvancedFiltering: true,
    }}>
    {Template.bind({})}
  </Story>
</Canvas>


#### Sorting

Sorting is defined by header configuration using the key `sort` and a list of key to be used.

<Canvas>
  <Story
    name="Sorting"
    args={{
      headers: headers.map(header => ({ ...header, sort: ['name'] })),
      rows,
    }}>
    {Template.bind({})}
  </Story>
</Canvas>

#### Action menu

Row can have action menu enabled by the configuration `rowActions`.

<Canvas>
  <Story
    name="Action menu"
    args={{
      headers,
      rows,
    }}>
    {Template.bind({})}
  </Story>
</Canvas>


#### Pagination

Table pagination can be enabled with `paging` and set the amount of entries with `rowsPerPage`.

<Canvas>
  <Story
    name="Pagination"
    args={{
      headers,
      rows: Array.from(new Array(100)).map((el, i) => ({
        name: `Row ${i}`,
      })),
      paging: true,
      rowsPerPage: 5
    }}>
    {Template.bind({})}
  </Story>
</Canvas>

#### Context menu

## Props table

<ArgsTable of={SortableTable} />
